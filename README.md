# mkinitcpio-swapgate — Resume-gated LUKS swap with per-boot keys (mkinitcpio)

## What it does
- Enables hybernation with an encrypted swap partition on mkinitcpio ramdisk systems (for example, Arch Linux based systems)
- On every boot it formats and encrypts swap with the brand new autogenerated key
- In case of hibernation, it prompts user password to decrypt the swap partition instead and resumes the hibernation

# Recovery

If resume decryption fails, the hook drops to an initramfs shell. You can:
* Try again (e.g. if the wrong password was typed) by:
* * Rebooting (press ctrl-alt-delete)
* Delete the hibernation state and force a cold boot by:
* * Removing cookie (`rm /run/boot-esp/resume.cookie`). The path is printed before the prompt.
* * Reboot by pressing ctrl-alt-delete
* Boot a new cold boot preserving the hiberation state
* * to do that just exit the recovery shell
* * that's cool because you can actually boot a fresh system while keeping the hibernated state for later
* * the swap won't work for that boot, you'll have to decrypt it manually to use it or to hibernate that boot

## Motivation
You don’t want hibernation to auto-restore without user presence, or the sensitive memory data to be dumped on a hard drive unencrypted. The resume operation requires your swap key passphrase **only when booting after hibernation**; normal boots rotate keys automatically.

## Use case

I have partially encrypted drives. Important files, $HOME, and backups are encrypted. The problem is if I hibernate my system all my encrypted keys are dumped from the memroy to the disk. Someone can access all encrypted data without being prompted for any password, simply by booting up.

This encrypts the swap partition with a random password on every boot, but enables myself to use one standard password to access my last hibernated state.

It does so by ecnrypting the autogenerated passwords with a public RSA key, and decrypting it when needed with a private RSA key, thus prompting for password. On hibernation, systemd-sleep hook adds a cookie (a plain file) to /boot to let us know the hibernation image is available, so on the next boot we'll decrypt the existing password and open the cryptsetup device instead of autogenerating the new password and re-formating the LUKS and swap partitions.

There are existing solutions for dracut initramfs system, but none that are trustwordy or reliable enough for mkinitcpio based systems (like Arch Linux)


## What it does (in detail):
- **Cold boot:** initramfs generates a fresh random 256-bit swap key `K`, formats LUKS2 swap with a *fast* PBKDF2, wraps `K` with an **RSA-OAEP** public key and stores only the wrapped key on the ESP, then enables swap. **No prompts.**
- **Resume boot:** initramfs prompts **once** for the RSA private key passphrase, unwraps `K`, opens LUKS swap **read-only**, and the kernel resumes from `/dev/mapper/${MAP_NAME}`. After resume, normal userland can `swapon` as usual.
- **systemd sleep hook:** when hibernating, adds a cookie file to /boot to make us know if we're supposed to start into cold boot mode or resume boot mode

## Files in this repo

```
.
├── etc/
│ └── swapgate.conf # config: PARTUUIDs & ESP paths
├── initcpio/
│ ├── hooks/swapgate # mkinitcpio early hook (OpenSSL & cryptsetup flow)
│ └── install/swapgate # mkinitcpio install script (adds bins/modules)
├── systemd-sleep-hook/
│ └── 99-resume-cookie.sh # writes/removes /boot cookie on hibernate/resume
├── setup.sh # generates RSA keys & initial wrapped key
├── test.sh # QEMU test harness (sandbox disk/ESP)
└── Makefile # install & test targets

```

## Prerequisites
- Arch Linux based OS (mkinitcpio)
- Packages (runtime): `cryptsetup`, `openssl`
- Packages (testing): `sgdisk`, `qemu-system-x86_64`
- Kernel cmdline includes: `resume=/dev/mapper/swap` (maps to `${MAP_NAME}` in config).


## Configure
Copy `etc/swapgate.conf.example` to `etc/swapgate.conf`.

Edit `etc/swapgate.conf`:

```sh
# Required: stable IDs
SWAP_PARTUUID="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
ESP_PARTUUID="yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy"

# Mapper name
MAP_NAME="swap"

# Paths on ESP (relative to /boot or $BOOT)
COOKIE_PATH="/resume.cookie"
PUBKEY_PATH="/rsa/swapwrap.pub"
ID_ENC_PATH="/rsa/swapwrap.enc.key"
ENCK_PATH="/rsa/swap.key.rsa"
```

# Get PARTUUIDs:

```sh
lsblk -no PARTUUID /dev/<swap-part>
lsblk -no PARTUUID /dev/<esp-part>
```

We're using PARTUUIDs because they're more reliable - they don't require udev triggering rules and waiting for them to settle. That can cause race conditions if for example fs UUIDS were used instead. PARTUUIDs are available straight to the kernel. Also when overriding the new swap LUKS container and formating a new swap inside of it, we don't have to worry about UUIDs - PARTUUID stay the same.

# Warranty (responsibility)

Any usage of this script comes with absolutely no warranty and very limited testing.
It's up to you to make sure the scripts what they're supposted to do.

The `test.sh` script expects to be run as root and it creates a raw qemu image as a loop device and then it formats mock partitions inside of it. These are destructive operations and if pointed to the wrong location it can whipe filesystems and data on them permanately.

`setup.sh` script expects a /boot mounted read-write and writes files on the locations configured in `swapgate.conf`. If there are already files at that location they're gone.

`setup.sh` can be run without root if a directories with user write permissions are created on /boot prior to running it. `setup.sh` won't format the swap partition but print the commands to do that instead. The same ones will be used by the hook later, so verify them before running those commands.

The mkinitcpio runs the same commands to re-format the swap partition on every cold boot, so that's descructive as well. There are safe-guards purely for that reason, but still something can go wrong and it's up to you to test.

Every time you use `sudo` or root be careful.

# One-time setup

Generate RSA keys on ESP and an initial wrapped key:

```sh
sudo ./setup.sh
```

This script generates RSA public / private keypair on /boot partition, generates the initial swap password and prints the commands to encrypt your swap.

# Safeguards

The hook is destructive towards the SWAP partition. Whatever you've configured as a `SWAP_PARTUUID` in the `swapgate.conf` will be formated on every boot to brand new LUKS container and a new swap with a no questions asked `mkswap -f` command.

Because of that I've implemented a few safeguards:
* If it doesn't resolve to a block device, it bails out
* If its not a partition, it bails out
* The resolved PARTUUID must match the original PARTUUID
* The GPT partition type must be swap. You can skip this one by setting `ALLOW_NONSWAP_PARTTYPE` to 1 in `swapgate.conf`
* It already already must be LUKS formatted (LUKS header detected)
* Must not be already mounted when the hook is running (during boot)

All these safety checks can be skipped by setting `DANGEROUS_SKIP_SAFETY_CHECKS_IM_NOT_A_DUMMY` to 1 in `swapgate.conf`

# Install

```sh
sudo make install
```

In `/etc/mkinitcpio.conf` put swapgate just before filesystems hook:

```sh
HOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block swapgate filesystems resume fsck)
```

# Rebuild the initramfs you actually boot (example for linux)
sudo mkinitcpio -p linux
```
In that case even if the boot fails for default boot, the lts images will still work.

To rebuild everything use:

```sh

sudo mkinitcpio -P
```

Ensure your kernel options have:

```
... resume=/dev/mapper/swap ...
```

or whatever mapping name is set up in `swapgate.conf`

Lastly, don't forget to comment out your swap from `/etc/fstab` and `/etc/crypttab`.

# Test in a sandbox (QEMU)

Run mkinitcpio if needed:
```sh
mkinitcpio -p linux
```

Create a raw disk with the exact PARTUUIDs from your config and boot your real kernel+initramfs:

```sh
sudo make test     # cold path
sudo CREATE_COOKIE=1 make test  # resume path (cookie present)
```

By default it uses emulated qemu64 cpu, but you can change that to use host CPU with KVM by setting `QEMU_CPU=host`

Please not that by default the fallback image is used for testing because the autodetect hook strips all the modules needed to run inside the qemu emulation. I recommend running `lsinitcpio -l` on images before booting for real.

# Uninstall

```sh
sudo make uninstall
sudo mkinitcpio -p linux
sudo rm -fr /boot/rsa/ /boot/resume.cookie
```

